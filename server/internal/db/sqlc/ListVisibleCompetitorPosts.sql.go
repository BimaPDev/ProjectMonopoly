// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: ListVisibleCompetitorPosts.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const listVisibleCompetitorPosts = `-- name: ListVisibleCompetitorPosts :many
SELECT cp.id, cp.competitor_id, cp.platform, cp.post_id, cp.content, cp.media, cp.posted_at, cp.engagement, cp.hashtags, cp.scraped_at
FROM competitor_posts cp
JOIN user_competitors uc ON uc.competitor_id = cp.competitor_id
WHERE uc.user_id = $1
  AND (
    uc.visibility = 'global'
    OR uc.visibility = 'user'
    OR (uc.visibility = 'group' AND uc.group_id = $2)
  )
ORDER BY cp.posted_at DESC
`

type ListVisibleCompetitorPostsParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

func (q *Queries) ListVisibleCompetitorPosts(ctx context.Context, arg ListVisibleCompetitorPostsParams) ([]CompetitorPost, error) {
	rows, err := q.db.QueryContext(ctx, listVisibleCompetitorPosts, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompetitorPost
	for rows.Next() {
		var i CompetitorPost
		if err := rows.Scan(
			&i.ID,
			&i.CompetitorID,
			&i.Platform,
			&i.PostID,
			&i.Content,
			&i.Media,
			&i.PostedAt,
			&i.Engagement,
			pq.Array(&i.Hashtags),
			&i.ScrapedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
