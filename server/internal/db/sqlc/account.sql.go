// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT COUNT(*) > 0 AS exists
FROM users
WHERE email = $1
`

// Check if only email exists (for OAuth)
func (q *Queries) CheckEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsernameOrEmailExists = `-- name: CheckUsernameOrEmailExists :one
SELECT COUNT(*) > 0 AS exists
FROM users
WHERE username = $1 OR email = $2
`

type CheckUsernameOrEmailExistsParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

// Check if username or email exists
func (q *Queries) CheckUsernameOrEmailExists(ctx context.Context, arg CheckUsernameOrEmailExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUsernameOrEmailExists, arg.Username, arg.Email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCompetitor = `-- name: CreateCompetitor :one
INSERT INTO competitors (display_name)
VALUES ($1)
RETURNING id, last_checked, total_posts, display_name
`

func (q *Queries) CreateCompetitor(ctx context.Context, displayName sql.NullString) (Competitor, error) {
	row := q.db.QueryRowContext(ctx, createCompetitor, displayName)
	var i Competitor
	err := row.Scan(
		&i.ID,
		&i.LastChecked,
		&i.TotalPosts,
		&i.DisplayName,
	)
	return i, err
}

const createGameContext = `-- name: CreateGameContext :one
INSERT INTO game_contexts (
    user_id, group_id,
    game_title, studio_name, game_summary, platforms, engine_tech,
    primary_genre, subgenre, key_mechanics, playtime_length, art_style, tone,
    intended_audience, age_range, player_motivation, comparable_games,
    marketing_objective, key_events_dates, call_to_action,
    content_restrictions, competitors_to_avoid, additional_info
)
VALUES (
    $1, $2,
    $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13,
    $14, $15, $16, $17,
    $18, $19, $20,
    $21, $22 , $23
)
RETURNING id, user_id, group_id, game_title, studio_name, game_summary, platforms, engine_tech, primary_genre, subgenre, key_mechanics, playtime_length, art_style, tone, intended_audience, age_range, player_motivation, comparable_games, marketing_objective, key_events_dates, call_to_action, content_restrictions, competitors_to_avoid, additional_info, extraction_method, original_file_name, created_at, updated_at
`

type CreateGameContextParams struct {
	UserID              int32          `json:"user_id"`
	GroupID             sql.NullInt32  `json:"group_id"`
	GameTitle           string         `json:"game_title"`
	StudioName          sql.NullString `json:"studio_name"`
	GameSummary         sql.NullString `json:"game_summary"`
	Platforms           []string       `json:"platforms"`
	EngineTech          sql.NullString `json:"engine_tech"`
	PrimaryGenre        sql.NullString `json:"primary_genre"`
	Subgenre            sql.NullString `json:"subgenre"`
	KeyMechanics        sql.NullString `json:"key_mechanics"`
	PlaytimeLength      sql.NullString `json:"playtime_length"`
	ArtStyle            sql.NullString `json:"art_style"`
	Tone                sql.NullString `json:"tone"`
	IntendedAudience    sql.NullString `json:"intended_audience"`
	AgeRange            sql.NullString `json:"age_range"`
	PlayerMotivation    sql.NullString `json:"player_motivation"`
	ComparableGames     sql.NullString `json:"comparable_games"`
	MarketingObjective  sql.NullString `json:"marketing_objective"`
	KeyEventsDates      sql.NullString `json:"key_events_dates"`
	CallToAction        sql.NullString `json:"call_to_action"`
	ContentRestrictions sql.NullString `json:"content_restrictions"`
	CompetitorsToAvoid  sql.NullString `json:"competitors_to_avoid"`
	AdditionalInfo      sql.NullString `json:"additional_info"`
}

func (q *Queries) CreateGameContext(ctx context.Context, arg CreateGameContextParams) (GameContext, error) {
	row := q.db.QueryRowContext(ctx, createGameContext,
		arg.UserID,
		arg.GroupID,
		arg.GameTitle,
		arg.StudioName,
		arg.GameSummary,
		pq.Array(arg.Platforms),
		arg.EngineTech,
		arg.PrimaryGenre,
		arg.Subgenre,
		arg.KeyMechanics,
		arg.PlaytimeLength,
		arg.ArtStyle,
		arg.Tone,
		arg.IntendedAudience,
		arg.AgeRange,
		arg.PlayerMotivation,
		arg.ComparableGames,
		arg.MarketingObjective,
		arg.KeyEventsDates,
		arg.CallToAction,
		arg.ContentRestrictions,
		arg.CompetitorsToAvoid,
		arg.AdditionalInfo,
	)
	var i GameContext
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.GameTitle,
		&i.StudioName,
		&i.GameSummary,
		pq.Array(&i.Platforms),
		&i.EngineTech,
		&i.PrimaryGenre,
		&i.Subgenre,
		&i.KeyMechanics,
		&i.PlaytimeLength,
		&i.ArtStyle,
		&i.Tone,
		&i.IntendedAudience,
		&i.AgeRange,
		&i.PlayerMotivation,
		&i.ComparableGames,
		&i.MarketingObjective,
		&i.KeyEventsDates,
		&i.CallToAction,
		&i.ContentRestrictions,
		&i.CompetitorsToAvoid,
		&i.AdditionalInfo,
		&i.ExtractionMethod,
		&i.OriginalFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (user_id, name, description, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, user_id, name, description, created_at, updated_at
`

type CreateGroupParams struct {
	UserID      int32          `json:"user_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.UserID, arg.Name, arg.Description)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOAuthUser = `-- name: CreateOAuthUser :one
INSERT INTO users (username, email, oauth_provider, oauth_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
ON CONFLICT (email) 
DO UPDATE SET username = EXCLUDED.username, updated_at = NOW()
RETURNING id, username, email, oauth_provider, oauth_id, created_at, updated_at
`

type CreateOAuthUserParams struct {
	Username      string         `json:"username"`
	Email         string         `json:"email"`
	OauthProvider sql.NullString `json:"oauth_provider"`
	OauthID       sql.NullString `json:"oauth_id"`
}

type CreateOAuthUserRow struct {
	ID            int32          `json:"id"`
	Username      string         `json:"username"`
	Email         string         `json:"email"`
	OauthProvider sql.NullString `json:"oauth_provider"`
	OauthID       sql.NullString `json:"oauth_id"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
}

// Register a new OAuth user (if they don't exist, update username if needed)
func (q *Queries) CreateOAuthUser(ctx context.Context, arg CreateOAuthUserParams) (CreateOAuthUserRow, error) {
	row := q.db.QueryRowContext(ctx, createOAuthUser,
		arg.Username,
		arg.Email,
		arg.OauthProvider,
		arg.OauthID,
	)
	var i CreateOAuthUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.OauthProvider,
		&i.OauthID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, expires_at)
VALUES ($1, NOW() + INTERVAL '24 hours')
RETURNING id, user_id, created_at, expires_at
`

// Create a new session with configurable expiration
func (q *Queries) CreateSession(ctx context.Context, userID int32) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createSocialMediaData = `-- name: CreateSocialMediaData :exec

INSERT INTO socialmedia_data (
  group_id,
  platform,
  type,
  data,
  created_at,
  updated_at
)
VALUES (
  $1,       -- group_id    (INT)
  $2,      -- platform    (VARCHAR)
  $3,       -- type        (VARCHAR)
  $4::jsonb,-- data        (JSONB)
  NOW(),
  NOW()
)
`

type CreateSocialMediaDataParams struct {
	GroupID  int32           `json:"group_id"`
	Platform string          `json:"platform"`
	Type     string          `json:"type"`
	Column4  json.RawMessage `json:"column_4"`
}

// uploding group items
func (q *Queries) CreateSocialMediaData(ctx context.Context, arg CreateSocialMediaDataParams) error {
	_, err := q.db.ExecContext(ctx, createSocialMediaData,
		arg.GroupID,
		arg.Platform,
		arg.Type,
		arg.Column4,
	)
	return err
}

const createUploadJob = `-- name: CreateUploadJob :one
INSERT INTO upload_jobs (
  id,
  user_id,
  platform,
  video_path,
  storage_type,
  file_url,
  scheduled_date,
  status,
  user_title,
  user_hashtags,
  group_id,
  created_at,
  updated_at

)
VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9,$10, $11,NOW(), NOW()
)
RETURNING id, user_id, platform, video_path, storage_type, file_url, status, user_title, user_hashtags, created_at, updated_at, group_id
`

type CreateUploadJobParams struct {
	ID            string         `json:"id"`
	UserID        int32          `json:"user_id"`
	Platform      string         `json:"platform"`
	VideoPath     string         `json:"video_path"`
	StorageType   string         `json:"storage_type"`
	FileUrl       sql.NullString `json:"file_url"`
	ScheduledDate sql.NullTime   `json:"scheduled_date"`
	Status        string         `json:"status"`
	UserTitle     sql.NullString `json:"user_title"`
	UserHashtags  []string       `json:"user_hashtags"`
	GroupID       sql.NullInt32  `json:"group_id"`
}

type CreateUploadJobRow struct {
	ID           string         `json:"id"`
	UserID       int32          `json:"user_id"`
	Platform     string         `json:"platform"`
	VideoPath    string         `json:"video_path"`
	StorageType  string         `json:"storage_type"`
	FileUrl      sql.NullString `json:"file_url"`
	Status       string         `json:"status"`
	UserTitle    sql.NullString `json:"user_title"`
	UserHashtags []string       `json:"user_hashtags"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	GroupID      sql.NullInt32  `json:"group_id"`
}

func (q *Queries) CreateUploadJob(ctx context.Context, arg CreateUploadJobParams) (CreateUploadJobRow, error) {
	row := q.db.QueryRowContext(ctx, createUploadJob,
		arg.ID,
		arg.UserID,
		arg.Platform,
		arg.VideoPath,
		arg.StorageType,
		arg.FileUrl,
		arg.ScheduledDate,
		arg.Status,
		arg.UserTitle,
		pq.Array(arg.UserHashtags),
		arg.GroupID,
	)
	var i CreateUploadJobRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Platform,
		&i.VideoPath,
		&i.StorageType,
		&i.FileUrl,
		&i.Status,
		&i.UserTitle,
		pq.Array(&i.UserHashtags),
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GroupID,
	)
	return i, err
}

const createUserWithPassword = `-- name: CreateUserWithPassword :one
INSERT INTO users (username, email, password_hash, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, username, email, created_at, updated_at
`

type CreateUserWithPasswordParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

type CreateUserWithPasswordRow struct {
	ID        int32        `json:"id"`
	Username  string       `json:"username"`
	Email     string       `json:"email"`
	CreatedAt sql.NullTime `json:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

// Register a new user with a password
func (q *Queries) CreateUserWithPassword(ctx context.Context, arg CreateUserWithPasswordParams) (CreateUserWithPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, createUserWithPassword, arg.Username, arg.Email, arg.PasswordHash)
	var i CreateUserWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = $1
`

// Delete a session (logout)
func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteSocialMediaData = `-- name: DeleteSocialMediaData :exec
DELETE FROM socialmedia_data
WHERE id = $1
`

func (q *Queries) DeleteSocialMediaData(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSocialMediaData, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

// Delete a user
func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const fetchNextPendingJob = `-- name: FetchNextPendingJob :one
UPDATE upload_jobs
SET status = 'processing'
WHERE id = (
    SELECT id FROM upload_jobs
    WHERE status = 'pending' AND session_id IS NOT NULL
    ORDER BY created_at
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, user_id, group_id, platform, video_path, storage_type, file_url, status, caption, user_title, user_hashtags, ai_title, ai_hashtags, ai_post_time, created_at, updated_at, scheduled_date
`

func (q *Queries) FetchNextPendingJob(ctx context.Context) (UploadJob, error) {
	row := q.db.QueryRowContext(ctx, fetchNextPendingJob)
	var i UploadJob
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Platform,
		&i.VideoPath,
		&i.StorageType,
		&i.FileUrl,
		&i.Status,
		&i.Caption,
		&i.UserTitle,
		pq.Array(&i.UserHashtags),
		&i.AiTitle,
		pq.Array(&i.AiHashtags),
		&i.AiPostTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScheduledDate,
	)
	return i, err
}

const getCompetitorByPlatformUsername = `-- name: GetCompetitorByPlatformUsername :one
SELECT c.id, c.last_checked, c.total_posts, c.display_name FROM competitors c
JOIN competitor_profiles cp ON cp.competitor_id = c.id
WHERE cp.platform = $1 AND LOWER(cp.handle) = LOWER($2)
`

type GetCompetitorByPlatformUsernameParams struct {
	Platform string `json:"platform"`
	Lower    string `json:"lower"`
}

func (q *Queries) GetCompetitorByPlatformUsername(ctx context.Context, arg GetCompetitorByPlatformUsernameParams) (Competitor, error) {
	row := q.db.QueryRowContext(ctx, getCompetitorByPlatformUsername, arg.Platform, arg.Lower)
	var i Competitor
	err := row.Scan(
		&i.ID,
		&i.LastChecked,
		&i.TotalPosts,
		&i.DisplayName,
	)
	return i, err
}

const getFollowerByDate = `-- name: GetFollowerByDate :one
SELECT follower_count
FROM daily_followers
ORDER BY record_date DESC
LIMIT 1
`

func (q *Queries) GetFollowerByDate(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowerByDate)
	var follower_count int64
	err := row.Scan(&follower_count)
	return follower_count, err
}

const getGameContextByGroupID = `-- name: GetGameContextByGroupID :one
SELECT id, user_id, group_id, game_title, studio_name, game_summary, platforms, engine_tech, primary_genre, subgenre, key_mechanics, playtime_length, art_style, tone, intended_audience, age_range, player_motivation, comparable_games, marketing_objective, key_events_dates, call_to_action, content_restrictions, competitors_to_avoid, additional_info, extraction_method, original_file_name, created_at, updated_at FROM game_contexts
WHERE group_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetGameContextByGroupID(ctx context.Context, groupID sql.NullInt32) (GameContext, error) {
	row := q.db.QueryRowContext(ctx, getGameContextByGroupID, groupID)
	var i GameContext
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.GameTitle,
		&i.StudioName,
		&i.GameSummary,
		pq.Array(&i.Platforms),
		&i.EngineTech,
		&i.PrimaryGenre,
		&i.Subgenre,
		&i.KeyMechanics,
		&i.PlaytimeLength,
		&i.ArtStyle,
		&i.Tone,
		&i.IntendedAudience,
		&i.AgeRange,
		&i.PlayerMotivation,
		&i.ComparableGames,
		&i.MarketingObjective,
		&i.KeyEventsDates,
		&i.CallToAction,
		&i.ContentRestrictions,
		&i.CompetitorsToAvoid,
		&i.AdditionalInfo,
		&i.ExtractionMethod,
		&i.OriginalFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameContextByUserID = `-- name: GetGameContextByUserID :one
SELECT id, user_id, group_id, game_title, studio_name, game_summary, platforms, engine_tech, primary_genre, subgenre, key_mechanics, playtime_length, art_style, tone, intended_audience, age_range, player_motivation, comparable_games, marketing_objective, key_events_dates, call_to_action, content_restrictions, competitors_to_avoid, additional_info, extraction_method, original_file_name, created_at, updated_at FROM game_contexts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetGameContextByUserID(ctx context.Context, userID int32) (GameContext, error) {
	row := q.db.QueryRowContext(ctx, getGameContextByUserID, userID)
	var i GameContext
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.GameTitle,
		&i.StudioName,
		&i.GameSummary,
		pq.Array(&i.Platforms),
		&i.EngineTech,
		&i.PrimaryGenre,
		&i.Subgenre,
		&i.KeyMechanics,
		&i.PlaytimeLength,
		&i.ArtStyle,
		&i.Tone,
		&i.IntendedAudience,
		&i.AgeRange,
		&i.PlayerMotivation,
		&i.ComparableGames,
		&i.MarketingObjective,
		&i.KeyEventsDates,
		&i.CallToAction,
		&i.ContentRestrictions,
		&i.CompetitorsToAvoid,
		&i.AdditionalInfo,
		&i.ExtractionMethod,
		&i.OriginalFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT id, user_id, name, description, created_at, updated_at
FROM groups
WHERE id = $1
`

func (q *Queries) GetGroupByID(ctx context.Context, id int32) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupByID, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupCompetitors = `-- name: GetGroupCompetitors :many
SELECT
  c.id,
  c.display_name,
  c.last_checked,
  c.total_posts,
  cp.id as profile_id,
  cp.platform,
  cp.handle as username,
  cp.profile_url,
  cp.followers,
  cp.engagement_rate,
  cp.growth_rate,
  cp.posting_frequency
FROM competitors c
JOIN user_competitors uc ON uc.competitor_id = c.id
LEFT JOIN competitor_profiles cp ON cp.competitor_id = c.id
WHERE uc.user_id = $1
`

type GetGroupCompetitorsRow struct {
	ID               uuid.UUID      `json:"id"`
	DisplayName      sql.NullString `json:"display_name"`
	LastChecked      sql.NullTime   `json:"last_checked"`
	TotalPosts       sql.NullInt64  `json:"total_posts"`
	ProfileID        uuid.NullUUID  `json:"profile_id"`
	Platform         sql.NullString `json:"platform"`
	Username         sql.NullString `json:"username"`
	ProfileUrl       sql.NullString `json:"profile_url"`
	Followers        sql.NullInt64  `json:"followers"`
	EngagementRate   sql.NullString `json:"engagement_rate"`
	GrowthRate       sql.NullString `json:"growth_rate"`
	PostingFrequency sql.NullString `json:"posting_frequency"`
}

func (q *Queries) GetGroupCompetitors(ctx context.Context, userID int32) ([]GetGroupCompetitorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupCompetitors, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupCompetitorsRow
	for rows.Next() {
		var i GetGroupCompetitorsRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LastChecked,
			&i.TotalPosts,
			&i.ProfileID,
			&i.Platform,
			&i.Username,
			&i.ProfileUrl,
			&i.Followers,
			&i.EngagementRate,
			&i.GrowthRate,
			&i.PostingFrequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupItemByGroupID = `-- name: GetGroupItemByGroupID :many
SELECT id, group_id, platform, data, created_at, updated_at
FROM group_items
WHERE group_id = $1
`

type GetGroupItemByGroupIDRow struct {
	ID        int32           `json:"id"`
	GroupID   int32           `json:"group_id"`
	Platform  string          `json:"platform"`
	Data      json.RawMessage `json:"data"`
	CreatedAt sql.NullTime    `json:"created_at"`
	UpdatedAt sql.NullTime    `json:"updated_at"`
}

func (q *Queries) GetGroupItemByGroupID(ctx context.Context, groupID int32) ([]GetGroupItemByGroupIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupItemByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupItemByGroupIDRow
	for rows.Next() {
		var i GetGroupItemByGroupIDRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Platform,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOAuthUserByEmail = `-- name: GetOAuthUserByEmail :one
SELECT id, username, email, oauth_provider, oauth_id, created_at, updated_at
FROM users
WHERE email = $1
`

type GetOAuthUserByEmailRow struct {
	ID            int32          `json:"id"`
	Username      string         `json:"username"`
	Email         string         `json:"email"`
	OauthProvider sql.NullString `json:"oauth_provider"`
	OauthID       sql.NullString `json:"oauth_id"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
}

// Get user by email (for OAuth login)
func (q *Queries) GetOAuthUserByEmail(ctx context.Context, email string) (GetOAuthUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getOAuthUserByEmail, email)
	var i GetOAuthUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.OauthProvider,
		&i.OauthID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, user_id, created_at, expires_at 
FROM sessions 
WHERE id = $1
`

// Get session by ID
func (q *Queries) GetSession(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUploadJob = `-- name: GetUploadJob :one
SELECT id, user_id, platform, video_path, storage_type, file_url, status, created_at, updated_at
FROM upload_jobs
WHERE id = $1
`

type GetUploadJobRow struct {
	ID          string         `json:"id"`
	UserID      int32          `json:"user_id"`
	Platform    string         `json:"platform"`
	VideoPath   string         `json:"video_path"`
	StorageType string         `json:"storage_type"`
	FileUrl     sql.NullString `json:"file_url"`
	Status      string         `json:"status"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

// Get upload job by ID
func (q *Queries) GetUploadJob(ctx context.Context, id string) (GetUploadJobRow, error) {
	row := q.db.QueryRowContext(ctx, getUploadJob, id)
	var i GetUploadJobRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Platform,
		&i.VideoPath,
		&i.StorageType,
		&i.FileUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadJobByGID = `-- name: GetUploadJobByGID :many
 select id, group_id,platform,status, created_at
 from upload_jobs 
 where group_id = $1 order by id
`

type GetUploadJobByGIDRow struct {
	ID        string        `json:"id"`
	GroupID   sql.NullInt32 `json:"group_id"`
	Platform  string        `json:"platform"`
	Status    string        `json:"status"`
	CreatedAt sql.NullTime  `json:"created_at"`
}

func (q *Queries) GetUploadJobByGID(ctx context.Context, groupID sql.NullInt32) ([]GetUploadJobByGIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUploadJobByGID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUploadJobByGIDRow
	for rows.Next() {
		var i GetUploadJobByGIDRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Platform,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmailWithPassword = `-- name: GetUserByEmailWithPassword :one
SELECT id, username, email, password_hash, created_at, updated_at
FROM users
WHERE email = $1
`

type GetUserByEmailWithPasswordRow struct {
	ID           int32        `json:"id"`
	Username     string       `json:"username"`
	Email        string       `json:"email"`
	PasswordHash string       `json:"password_hash"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
}

// Get user by email (for password login)
func (q *Queries) GetUserByEmailWithPassword(ctx context.Context, email string) (GetUserByEmailWithPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailWithPassword, email)
	var i GetUserByEmailWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, created_at, updated_at
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID        int32        `json:"id"`
	Username  string       `json:"username"`
	Email     string       `json:"email"`
	CreatedAt sql.NullTime `json:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

// Get user by ID
func (q *Queries) GetUserByID(ctx context.Context, id int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserIDByUsernameEmail = `-- name: GetUserIDByUsernameEmail :one
SELECT id
FROM users
WHERE username = $1
  AND email    = $2
`

type GetUserIDByUsernameEmailParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) GetUserIDByUsernameEmail(ctx context.Context, arg GetUserIDByUsernameEmailParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByUsernameEmail, arg.Username, arg.Email)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertFollowerCount = `-- name: InsertFollowerCount :exec
insert into daily_followers(
  record_date,
  follower_count
) values (
  $1, -- record_date (INT)
  $2  -- date           (timestamp)
)
`

type InsertFollowerCountParams struct {
	RecordDate    time.Time `json:"record_date"`
	FollowerCount int64     `json:"follower_count"`
}

func (q *Queries) InsertFollowerCount(ctx context.Context, arg InsertFollowerCountParams) error {
	_, err := q.db.ExecContext(ctx, insertFollowerCount, arg.RecordDate, arg.FollowerCount)
	return err
}

const insertGroupItemIfNotExists = `-- name: InsertGroupItemIfNotExists :execrows
INSERT INTO group_items (group_id,platform,data, created_at, updated_at)
VALUES ($1,$2,$3, NOW(), NOW())
ON CONFLICT (group_id, platform) DO NOTHING
`

type InsertGroupItemIfNotExistsParams struct {
	GroupID  int32           `json:"group_id"`
	Platform string          `json:"platform"`
	Data     json.RawMessage `json:"data"`
}

func (q *Queries) InsertGroupItemIfNotExists(ctx context.Context, arg InsertGroupItemIfNotExistsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertGroupItemIfNotExists, arg.GroupID, arg.Platform, arg.Data)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const linkUserToCompetitor = `-- name: LinkUserToCompetitor :exec
INSERT INTO user_competitors (user_id, group_id, competitor_id, visibility)
VALUES ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
`

type LinkUserToCompetitorParams struct {
	UserID       int32         `json:"user_id"`
	GroupID      sql.NullInt32 `json:"group_id"`
	CompetitorID uuid.UUID     `json:"competitor_id"`
	Visibility   string        `json:"visibility"`
}

func (q *Queries) LinkUserToCompetitor(ctx context.Context, arg LinkUserToCompetitorParams) error {
	_, err := q.db.ExecContext(ctx, linkUserToCompetitor,
		arg.UserID,
		arg.GroupID,
		arg.CompetitorID,
		arg.Visibility,
	)
	return err
}

const listAvailableCompetitorsToUser = `-- name: ListAvailableCompetitorsToUser :many
SELECT
  c.id,
  c.display_name,
  c.last_checked,
  c.total_posts
FROM competitors c
WHERE c.id NOT IN (
  SELECT competitor_id FROM user_competitors WHERE user_id = $1
)
`

type ListAvailableCompetitorsToUserRow struct {
	ID          uuid.UUID      `json:"id"`
	DisplayName sql.NullString `json:"display_name"`
	LastChecked sql.NullTime   `json:"last_checked"`
	TotalPosts  sql.NullInt64  `json:"total_posts"`
}

func (q *Queries) ListAvailableCompetitorsToUser(ctx context.Context, userID int32) ([]ListAvailableCompetitorsToUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listAvailableCompetitorsToUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailableCompetitorsToUserRow
	for rows.Next() {
		var i ListAvailableCompetitorsToUserRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LastChecked,
			&i.TotalPosts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameContextsByUser = `-- name: ListGameContextsByUser :many
SELECT id, user_id, group_id, game_title, studio_name, game_summary, platforms, engine_tech, primary_genre, subgenre, key_mechanics, playtime_length, art_style, tone, intended_audience, age_range, player_motivation, comparable_games, marketing_objective, key_events_dates, call_to_action, content_restrictions, competitors_to_avoid, additional_info, extraction_method, original_file_name, created_at, updated_at FROM game_contexts
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListGameContextsByUser(ctx context.Context, userID int32) ([]GameContext, error) {
	rows, err := q.db.QueryContext(ctx, listGameContextsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameContext
	for rows.Next() {
		var i GameContext
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.GameTitle,
			&i.StudioName,
			&i.GameSummary,
			pq.Array(&i.Platforms),
			&i.EngineTech,
			&i.PrimaryGenre,
			&i.Subgenre,
			&i.KeyMechanics,
			&i.PlaytimeLength,
			&i.ArtStyle,
			&i.Tone,
			&i.IntendedAudience,
			&i.AgeRange,
			&i.PlayerMotivation,
			&i.ComparableGames,
			&i.MarketingObjective,
			&i.KeyEventsDates,
			&i.CallToAction,
			&i.ContentRestrictions,
			&i.CompetitorsToAvoid,
			&i.AdditionalInfo,
			&i.ExtractionMethod,
			&i.OriginalFileName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupCompetitors = `-- name: ListGroupCompetitors :many
SELECT
  c.id,
  c.display_name,
  c.last_checked,
  c.total_posts,
  cp.id as profile_id,
  cp.platform,
  cp.handle as username,
  cp.profile_url,
  cp.followers,
  cp.engagement_rate,
  cp.growth_rate,
  cp.posting_frequency
FROM competitors c
JOIN user_competitors uc ON uc.competitor_id = c.id
LEFT JOIN competitor_profiles cp ON cp.competitor_id = c.id
WHERE uc.user_id = $1 AND uc.group_id = $2
`

type ListGroupCompetitorsParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

type ListGroupCompetitorsRow struct {
	ID               uuid.UUID      `json:"id"`
	DisplayName      sql.NullString `json:"display_name"`
	LastChecked      sql.NullTime   `json:"last_checked"`
	TotalPosts       sql.NullInt64  `json:"total_posts"`
	ProfileID        uuid.NullUUID  `json:"profile_id"`
	Platform         sql.NullString `json:"platform"`
	Username         sql.NullString `json:"username"`
	ProfileUrl       sql.NullString `json:"profile_url"`
	Followers        sql.NullInt64  `json:"followers"`
	EngagementRate   sql.NullString `json:"engagement_rate"`
	GrowthRate       sql.NullString `json:"growth_rate"`
	PostingFrequency sql.NullString `json:"posting_frequency"`
}

func (q *Queries) ListGroupCompetitors(ctx context.Context, arg ListGroupCompetitorsParams) ([]ListGroupCompetitorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroupCompetitors, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupCompetitorsRow
	for rows.Next() {
		var i ListGroupCompetitorsRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LastChecked,
			&i.TotalPosts,
			&i.ProfileID,
			&i.Platform,
			&i.Username,
			&i.ProfileUrl,
			&i.Followers,
			&i.EngagementRate,
			&i.GrowthRate,
			&i.PostingFrequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsByUser = `-- name: ListGroupsByUser :many
SELECT
  id,
  user_id,
  name,
  description,
  created_at,
  updated_at
FROM groups
WHERE user_id = $1
ORDER BY id
`

func (q *Queries) ListGroupsByUser(ctx context.Context, userID int32) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, listGroupsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSocialMediaDataByGroup = `-- name: ListSocialMediaDataByGroup :many
SELECT
  id,
  group_id,
  platform,
  type,
  data,
  created_at,
  updated_at
FROM socialmedia_data
WHERE group_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSocialMediaDataByGroup(ctx context.Context, groupID int32) ([]SocialmediaDatum, error) {
	rows, err := q.db.QueryContext(ctx, listSocialMediaDataByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SocialmediaDatum
	for rows.Next() {
		var i SocialmediaDatum
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Platform,
			&i.Type,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCompetitors = `-- name: ListUserCompetitors :many
SELECT
  c.id,
  c.display_name,
  c.last_checked,
  c.total_posts,
  cp.id as profile_id,
  cp.platform,
  cp.handle as username,
  cp.profile_url,
  cp.followers,
  cp.engagement_rate,
  cp.growth_rate,
  cp.posting_frequency
FROM competitors c
JOIN user_competitors uc ON uc.competitor_id = c.id
LEFT JOIN competitor_profiles cp ON cp.competitor_id = c.id
WHERE uc.user_id = $1
`

type ListUserCompetitorsRow struct {
	ID               uuid.UUID      `json:"id"`
	DisplayName      sql.NullString `json:"display_name"`
	LastChecked      sql.NullTime   `json:"last_checked"`
	TotalPosts       sql.NullInt64  `json:"total_posts"`
	ProfileID        uuid.NullUUID  `json:"profile_id"`
	Platform         sql.NullString `json:"platform"`
	Username         sql.NullString `json:"username"`
	ProfileUrl       sql.NullString `json:"profile_url"`
	Followers        sql.NullInt64  `json:"followers"`
	EngagementRate   sql.NullString `json:"engagement_rate"`
	GrowthRate       sql.NullString `json:"growth_rate"`
	PostingFrequency sql.NullString `json:"posting_frequency"`
}

func (q *Queries) ListUserCompetitors(ctx context.Context, userID int32) ([]ListUserCompetitorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserCompetitors, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserCompetitorsRow
	for rows.Next() {
		var i ListUserCompetitorsRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LastChecked,
			&i.TotalPosts,
			&i.ProfileID,
			&i.Platform,
			&i.Username,
			&i.ProfileUrl,
			&i.Followers,
			&i.EngagementRate,
			&i.GrowthRate,
			&i.PostingFrequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserUploadJobs = `-- name: ListUserUploadJobs :many
SELECT id, platform, video_path, storage_type, file_url, status, created_at, updated_at
FROM upload_jobs
WHERE user_id = $1
ORDER BY created_at DESC
`

type ListUserUploadJobsRow struct {
	ID          string         `json:"id"`
	Platform    string         `json:"platform"`
	VideoPath   string         `json:"video_path"`
	StorageType string         `json:"storage_type"`
	FileUrl     sql.NullString `json:"file_url"`
	Status      string         `json:"status"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

// List all upload jobs for a user
func (q *Queries) ListUserUploadJobs(ctx context.Context, userID int32) ([]ListUserUploadJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserUploadJobs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserUploadJobsRow
	for rows.Next() {
		var i ListUserUploadJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Platform,
			&i.VideoPath,
			&i.StorageType,
			&i.FileUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, created_at, updated_at
FROM users
ORDER BY created_at DESC
`

type ListUsersRow struct {
	ID        int32        `json:"id"`
	Username  string       `json:"username"`
	Email     string       `json:"email"`
	CreatedAt sql.NullTime `json:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

// List all users
func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroupItemData = `-- name: UpdateGroupItemData :exec
UPDATE group_items
SET data = $1::jsonb, updated_at = NOW()
WHERE group_id = $2 AND platform = $3
`

type UpdateGroupItemDataParams struct {
	Data     json.RawMessage `json:"data"`
	GroupID  int32           `json:"group_id"`
	Platform string          `json:"platform"`
}

func (q *Queries) UpdateGroupItemData(ctx context.Context, arg UpdateGroupItemDataParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupItemData, arg.Data, arg.GroupID, arg.Platform)
	return err
}

const updateSocialMediaData = `-- name: UpdateSocialMediaData :exec
UPDATE socialmedia_data
SET
  platform   = $2,
  data       = $3::jsonb,
  updated_at = NOW()
WHERE id = $1
`

type UpdateSocialMediaDataParams struct {
	ID       int32           `json:"id"`
	Platform string          `json:"platform"`
	Column3  json.RawMessage `json:"column_3"`
}

func (q *Queries) UpdateSocialMediaData(ctx context.Context, arg UpdateSocialMediaDataParams) error {
	_, err := q.db.ExecContext(ctx, updateSocialMediaData, arg.ID, arg.Platform, arg.Column3)
	return err
}

const updateUploadJobFileURL = `-- name: UpdateUploadJobFileURL :exec
UPDATE upload_jobs
SET file_url = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUploadJobFileURLParams struct {
	ID      string         `json:"id"`
	FileUrl sql.NullString `json:"file_url"`
}

// Update upload job file URL
func (q *Queries) UpdateUploadJobFileURL(ctx context.Context, arg UpdateUploadJobFileURLParams) error {
	_, err := q.db.ExecContext(ctx, updateUploadJobFileURL, arg.ID, arg.FileUrl)
	return err
}

const updateUploadJobStatus = `-- name: UpdateUploadJobStatus :exec
UPDATE upload_jobs
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUploadJobStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

// Update upload job status
func (q *Queries) UpdateUploadJobStatus(ctx context.Context, arg UpdateUploadJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUploadJobStatus, arg.ID, arg.Status)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2,
    email = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, username, email, created_at, updated_at
`

type UpdateUserParams struct {
	ID       int32  `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
}

type UpdateUserRow struct {
	ID        int32        `json:"id"`
	Username  string       `json:"username"`
	Email     string       `json:"email"`
	CreatedAt sql.NullTime `json:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

// Update user details
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser, arg.ID, arg.Username, arg.Email)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
