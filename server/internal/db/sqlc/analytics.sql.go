// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const getBestPostingDay = `-- name: GetBestPostingDay :one
SELECT
  EXTRACT(ISODOW FROM cp.posted_at)::int as best_day,
  AVG(COALESCE((cp.engagement->>'likes')::bigint, 0))::float8 as avg_likes,
  COUNT(*)::bigint as sample_size
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  AND cp.posted_at >= NOW() - INTERVAL '14 days'
  AND cp.posted_at IS NOT NULL
  AND NOT (
    cp.content ILIKE '%Patch Notes%' OR
    cp.content ILIKE '%Hotfix%' OR
    cp.content ILIKE '%Steam Deck%' OR
    cp.content ILIKE '%1080p%'
  )
GROUP BY EXTRACT(ISODOW FROM cp.posted_at)
ORDER BY avg_likes DESC
LIMIT 1
`

type GetBestPostingDayParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

type GetBestPostingDayRow struct {
	BestDay    int32   `json:"best_day"`
	AvgLikes   float64 `json:"avg_likes"`
	SampleSize int64   `json:"sample_size"`
}

// Returns the best day of week (1=Monday, 7=Sunday) based on average likes
// Uses 28-day window (4 weeks) for reliable weekly patterns
// NOTE: We only have DATE from scraper, not TIME, so ISODOW is the only reliable metric
func (q *Queries) GetBestPostingDay(ctx context.Context, arg GetBestPostingDayParams) (GetBestPostingDayRow, error) {
	row := q.db.QueryRowContext(ctx, getBestPostingDay, arg.UserID, arg.GroupID)
	var i GetBestPostingDayRow
	err := row.Scan(&i.BestDay, &i.AvgLikes, &i.SampleSize)
	return i, err
}

const getBestPostingHour = `-- name: GetBestPostingHour :one
SELECT
  EXTRACT(HOUR FROM cp.posted_at)::int as best_hour,
  AVG(
    COALESCE((cp.engagement->>'likes')::bigint, 0) + 
    COALESCE((cp.engagement->>'comments')::bigint, 0)
  )::float8 as avg_engagement,
  COUNT(*)::bigint as sample_size
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  AND cp.posted_at >= NOW() - INTERVAL '14 days'
  AND cp.posted_at IS NOT NULL
  AND NOT (
    cp.content ILIKE '%Patch Notes%' OR
    cp.content ILIKE '%Hotfix%' OR
    cp.content ILIKE '%Steam Deck%' OR
    cp.content ILIKE '%1080p%'
  )
GROUP BY EXTRACT(HOUR FROM cp.posted_at)
ORDER BY avg_engagement DESC
LIMIT 1
`

type GetBestPostingHourParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

type GetBestPostingHourRow struct {
	BestHour      int32   `json:"best_hour"`
	AvgEngagement float64 `json:"avg_engagement"`
	SampleSize    int64   `json:"sample_size"`
}

// Constraint C: Return the best posting hour (0-23) based on average engagement
// Uses the same 14-day window and relevance filters
func (q *Queries) GetBestPostingHour(ctx context.Context, arg GetBestPostingHourParams) (GetBestPostingHourRow, error) {
	row := q.db.QueryRowContext(ctx, getBestPostingHour, arg.UserID, arg.GroupID)
	var i GetBestPostingHourRow
	err := row.Scan(&i.BestHour, &i.AvgEngagement, &i.SampleSize)
	return i, err
}

const getCompetitorCount = `-- name: GetCompetitorCount :one
SELECT COUNT(DISTINCT c.id)::int as competitor_count
FROM competitors c
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
`

type GetCompetitorCountParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

// Returns the count of unique competitors for a user/group
func (q *Queries) GetCompetitorCount(ctx context.Context, arg GetCompetitorCountParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getCompetitorCount, arg.UserID, arg.GroupID)
	var competitor_count int32
	err := row.Scan(&competitor_count)
	return competitor_count, err
}

const getCompetitorHandles = `-- name: GetCompetitorHandles :many
SELECT DISTINCT LOWER(cpr.handle) as handle
FROM competitor_profiles cpr
JOIN competitors c ON c.id = cpr.competitor_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
`

type GetCompetitorHandlesParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

// Returns all competitor handles for a user/group to filter out competitor-branded hashtags
func (q *Queries) GetCompetitorHandles(ctx context.Context, arg GetCompetitorHandlesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitorHandles, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var handle string
		if err := rows.Scan(&handle); err != nil {
			return nil, err
		}
		items = append(items, handle)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompetitorPostCount14Days = `-- name: GetCompetitorPostCount14Days :one
SELECT COUNT(*)::bigint as post_count
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  AND cp.posted_at >= NOW() - INTERVAL '14 days'
`

type GetCompetitorPostCount14DaysParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

// Helper to check if we have any relevant data in the 14-day window
func (q *Queries) GetCompetitorPostCount14Days(ctx context.Context, arg GetCompetitorPostCount14DaysParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCompetitorPostCount14Days, arg.UserID, arg.GroupID)
	var post_count int64
	err := row.Scan(&post_count)
	return post_count, err
}

const getDailyEngagementTrends = `-- name: GetDailyEngagementTrends :many
SELECT
  DATE(cp.posted_at) as post_date,
  COUNT(*)::bigint as post_count,
  SUM(COALESCE((cp.engagement->>'likes')::bigint, 0))::bigint as total_likes,
  SUM(COALESCE((cp.engagement->>'comments')::bigint, 0))::bigint as total_comments,
  AVG(
    COALESCE((cp.engagement->>'likes')::bigint, 0) + 
    COALESCE((cp.engagement->>'comments')::bigint, 0)
  )::float8 as avg_engagement
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  AND cp.posted_at >= NOW() - ($3 || ' days')::interval
  AND cp.posted_at IS NOT NULL
GROUP BY DATE(cp.posted_at)
ORDER BY post_date ASC
`

type GetDailyEngagementTrendsParams struct {
	UserID  int32          `json:"user_id"`
	GroupID sql.NullInt32  `json:"group_id"`
	Column3 sql.NullString `json:"column_3"`
}

type GetDailyEngagementTrendsRow struct {
	PostDate      time.Time `json:"post_date"`
	PostCount     int64     `json:"post_count"`
	TotalLikes    int64     `json:"total_likes"`
	TotalComments int64     `json:"total_comments"`
	AvgEngagement float64   `json:"avg_engagement"`
}

// Returns daily aggregated engagement data for the dashboard chart
// $3 is the number of days to look back (7, 30, or 90)
func (q *Queries) GetDailyEngagementTrends(ctx context.Context, arg GetDailyEngagementTrendsParams) ([]GetDailyEngagementTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyEngagementTrends, arg.UserID, arg.GroupID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyEngagementTrendsRow
	for rows.Next() {
		var i GetDailyEngagementTrendsRow
		if err := rows.Scan(
			&i.PostDate,
			&i.PostCount,
			&i.TotalLikes,
			&i.TotalComments,
			&i.AvgEngagement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostingFrequency28Days = `-- name: GetPostingFrequency28Days :one
SELECT
  COUNT(*)::bigint as total_posts,
  (COUNT(*) / 2.0)::float8 as posts_per_week
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  AND cp.posted_at >= NOW() - INTERVAL '14 days'
`

type GetPostingFrequency28DaysParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

type GetPostingFrequency28DaysRow struct {
	TotalPosts   int64   `json:"total_posts"`
	PostsPerWeek float64 `json:"posts_per_week"`
}

// Returns total posts and posts per week over 28 days for competitor cadence analysis
func (q *Queries) GetPostingFrequency28Days(ctx context.Context, arg GetPostingFrequency28DaysParams) (GetPostingFrequency28DaysRow, error) {
	row := q.db.QueryRowContext(ctx, getPostingFrequency28Days, arg.UserID, arg.GroupID)
	var i GetPostingFrequency28DaysRow
	err := row.Scan(&i.TotalPosts, &i.PostsPerWeek)
	return i, err
}

const getTimeBoxedCompetitorInsights = `-- name: GetTimeBoxedCompetitorInsights :many

SELECT
  cp.id,
  cp.competitor_id,
  cp.platform,
  cp.post_id,
  cp.content,
  cp.posted_at,
  cp.engagement,
  c.display_name as competitor_name,
  cpr.handle as competitor_handle,
  -- Extract engagement metrics from JSONB
  COALESCE((cp.engagement->>'likes')::bigint, 0) + 
  COALESCE((cp.engagement->>'comments')::bigint, 0) as total_engagement
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN competitor_profiles cpr ON cpr.id = cp.profile_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  -- Constraint A: Time-box to last 14 days
  AND cp.posted_at >= NOW() - INTERVAL '14 days'
  -- Constraint B: Exclude technical posts (Patch Notes, Hotfix, Steam Deck, 1080p)
  AND NOT (
    cp.content ILIKE '%Patch Notes%' OR
    cp.content ILIKE '%Hotfix%' OR
    cp.content ILIKE '%Steam Deck%' OR
    cp.content ILIKE '%1080p%' OR
    cp.content ILIKE '%patch%note%' OR
    cp.content ILIKE '%hot%fix%'
  )
ORDER BY total_engagement DESC
LIMIT $3
`

type GetTimeBoxedCompetitorInsightsParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
	Limit   int32         `json:"limit"`
}

type GetTimeBoxedCompetitorInsightsRow struct {
	ID               int32                 `json:"id"`
	CompetitorID     uuid.NullUUID         `json:"competitor_id"`
	Platform         string                `json:"platform"`
	PostID           string                `json:"post_id"`
	Content          sql.NullString        `json:"content"`
	PostedAt         sql.NullTime          `json:"posted_at"`
	Engagement       pqtype.NullRawMessage `json:"engagement"`
	CompetitorName   sql.NullString        `json:"competitor_name"`
	CompetitorHandle string                `json:"competitor_handle"`
	TotalEngagement  int32                 `json:"total_engagement"`
}

// Optimized Competitor Analytics Queries for Marketing AI Pipeline
// Implements time-boxing (14 days), relevance filtering, and engagement aggregation
// Fetches competitor posts from the last 14 days, excluding technical content
func (q *Queries) GetTimeBoxedCompetitorInsights(ctx context.Context, arg GetTimeBoxedCompetitorInsightsParams) ([]GetTimeBoxedCompetitorInsightsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeBoxedCompetitorInsights, arg.UserID, arg.GroupID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeBoxedCompetitorInsightsRow
	for rows.Next() {
		var i GetTimeBoxedCompetitorInsightsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompetitorID,
			&i.Platform,
			&i.PostID,
			&i.Content,
			&i.PostedAt,
			&i.Engagement,
			&i.CompetitorName,
			&i.CompetitorHandle,
			&i.TotalEngagement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCompetitorHashtags = `-- name: GetTopCompetitorHashtags :many
SELECT
  hashtag,
  COUNT(*)::bigint as frequency
FROM (
  SELECT UNNEST(hashtags) as hashtag
  FROM competitor_posts cp
  JOIN competitors c ON c.id = cp.competitor_id
  JOIN user_competitors uc ON uc.competitor_id = c.id
  WHERE uc.user_id = $1
    AND (uc.group_id = $2 OR uc.group_id IS NULL)
    AND cp.posted_at >= NOW() - INTERVAL '14 days'
) as tags
WHERE LENGTH(hashtag) > 2
GROUP BY hashtag
ORDER BY frequency DESC
LIMIT 5
`

type GetTopCompetitorHashtagsParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

type GetTopCompetitorHashtagsRow struct {
	Hashtag   interface{} `json:"hashtag"`
	Frequency int64       `json:"frequency"`
}

// Returns top 5 used hashtags by competitors in last 28 days
func (q *Queries) GetTopCompetitorHashtags(ctx context.Context, arg GetTopCompetitorHashtagsParams) ([]GetTopCompetitorHashtagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopCompetitorHashtags, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCompetitorHashtagsRow
	for rows.Next() {
		var i GetTopCompetitorHashtagsRow
		if err := rows.Scan(&i.Hashtag, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCompetitorHooks = `-- name: GetTopCompetitorHooks :many
SELECT
  cp.id,
  c.display_name as competitor_name,
  cpr.handle as competitor_handle,
  cp.platform,
  LEFT(cp.content, 280) as hook,
  cp.posted_at,
  COALESCE((cp.engagement->>'likes')::bigint, 0) + 
  COALESCE((cp.engagement->>'comments')::bigint, 0) as total_engagement
FROM competitor_posts cp
JOIN competitors c ON c.id = cp.competitor_id
JOIN competitor_profiles cpr ON cpr.id = cp.profile_id
JOIN user_competitors uc ON uc.competitor_id = c.id
WHERE uc.user_id = $1
  AND (uc.group_id = $2 OR uc.group_id IS NULL)
  AND cp.posted_at >= NOW() - INTERVAL '14 days'
  AND cp.content IS NOT NULL
  AND LENGTH(cp.content) > 20  -- Filter out empty/minimal content
  AND NOT (
    cp.content ILIKE '%Patch Notes%' OR
    cp.content ILIKE '%Hotfix%' OR
    cp.content ILIKE '%Steam Deck%' OR
    cp.content ILIKE '%1080p%'
  )
ORDER BY total_engagement DESC
LIMIT $3
`

type GetTopCompetitorHooksParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
	Limit   int32         `json:"limit"`
}

type GetTopCompetitorHooksRow struct {
	ID               int32          `json:"id"`
	CompetitorName   sql.NullString `json:"competitor_name"`
	CompetitorHandle string         `json:"competitor_handle"`
	Platform         string         `json:"platform"`
	Hook             string         `json:"hook"`
	PostedAt         sql.NullTime   `json:"posted_at"`
	TotalEngagement  int32          `json:"total_engagement"`
}

// Returns the highest-engagement captions for inspiration (first 280 chars as hook)
func (q *Queries) GetTopCompetitorHooks(ctx context.Context, arg GetTopCompetitorHooksParams) ([]GetTopCompetitorHooksRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopCompetitorHooks, arg.UserID, arg.GroupID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCompetitorHooksRow
	for rows.Next() {
		var i GetTopCompetitorHooksRow
		if err := rows.Scan(
			&i.ID,
			&i.CompetitorName,
			&i.CompetitorHandle,
			&i.Platform,
			&i.Hook,
			&i.PostedAt,
			&i.TotalEngagement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
