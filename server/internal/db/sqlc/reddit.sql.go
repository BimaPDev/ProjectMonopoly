// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reddit.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createRedditSource = `-- name: CreateRedditSource :one
INSERT INTO reddit_sources (
  user_id, group_id, type, value, subreddit
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, user_id, group_id, type, value, subreddit, enabled, created_at
`

type CreateRedditSourceParams struct {
	UserID    int32          `json:"user_id"`
	GroupID   sql.NullInt32  `json:"group_id"`
	Type      string         `json:"type"`
	Value     string         `json:"value"`
	Subreddit sql.NullString `json:"subreddit"`
}

func (q *Queries) CreateRedditSource(ctx context.Context, arg CreateRedditSourceParams) (RedditSource, error) {
	row := q.db.QueryRowContext(ctx, createRedditSource,
		arg.UserID,
		arg.GroupID,
		arg.Type,
		arg.Value,
		arg.Subreddit,
	)
	var i RedditSource
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Type,
		&i.Value,
		&i.Subreddit,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRedditSource = `-- name: DeleteRedditSource :exec
DELETE FROM reddit_sources
WHERE id = $1 AND user_id = $2
`

type DeleteRedditSourceParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteRedditSource(ctx context.Context, arg DeleteRedditSourceParams) error {
	_, err := q.db.ExecContext(ctx, deleteRedditSource, arg.ID, arg.UserID)
	return err
}

const getRedditItem = `-- name: GetRedditItem :one
SELECT ri.id, ri.source_id, ri.platform, ri.subreddit, ri.external_id, ri.external_url, ri.title, ri.body, ri.author, ri.author_flair, ri.score, ri.num_comments, ri.created_utc, ri.fetched_at, ri.quality_score, ri.nsfw, ri.removed, ri.raw_json 
FROM reddit_items ri
JOIN reddit_sources rs ON ri.source_id = rs.id
WHERE ri.id = $1 AND rs.user_id = $2
`

type GetRedditItemParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetRedditItem(ctx context.Context, arg GetRedditItemParams) (RedditItem, error) {
	row := q.db.QueryRowContext(ctx, getRedditItem, arg.ID, arg.UserID)
	var i RedditItem
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Platform,
		&i.Subreddit,
		&i.ExternalID,
		&i.ExternalUrl,
		&i.Title,
		&i.Body,
		&i.Author,
		&i.AuthorFlair,
		&i.Score,
		&i.NumComments,
		&i.CreatedUtc,
		&i.FetchedAt,
		&i.QualityScore,
		&i.Nsfw,
		&i.Removed,
		&i.RawJson,
	)
	return i, err
}

const getRedditSource = `-- name: GetRedditSource :one
SELECT id, user_id, group_id, type, value, subreddit, enabled, created_at FROM reddit_sources
WHERE id = $1 AND user_id = $2
`

type GetRedditSourceParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetRedditSource(ctx context.Context, arg GetRedditSourceParams) (RedditSource, error) {
	row := q.db.QueryRowContext(ctx, getRedditSource, arg.ID, arg.UserID)
	var i RedditSource
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Type,
		&i.Value,
		&i.Subreddit,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const listRedditAlerts = `-- name: ListRedditAlerts :many
SELECT ra.id, ra.source_id, ra.window_start, ra.window_end, ra.metric, ra.current_value, ra.previous_value, ra.factor, ra.top_item_ids, ra.created_at 
FROM reddit_alerts ra
JOIN reddit_sources rs ON ra.source_id = rs.id
WHERE rs.user_id = $1
  AND ($4::int IS NULL OR rs.group_id = $4::int)
ORDER BY ra.created_at DESC
LIMIT $2 OFFSET $3
`

type ListRedditAlertsParams struct {
	UserID  int32         `json:"user_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
	GroupID sql.NullInt32 `json:"group_id"`
}

func (q *Queries) ListRedditAlerts(ctx context.Context, arg ListRedditAlertsParams) ([]RedditAlert, error) {
	rows, err := q.db.QueryContext(ctx, listRedditAlerts,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.GroupID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RedditAlert
	for rows.Next() {
		var i RedditAlert
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.WindowStart,
			&i.WindowEnd,
			&i.Metric,
			&i.CurrentValue,
			&i.PreviousValue,
			&i.Factor,
			&i.TopItemIds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRedditItems = `-- name: ListRedditItems :many
SELECT ri.id, ri.source_id, ri.platform, ri.subreddit, ri.external_id, ri.external_url, ri.title, ri.body, ri.author, ri.author_flair, ri.score, ri.num_comments, ri.created_utc, ri.fetched_at, ri.quality_score, ri.nsfw, ri.removed, ri.raw_json 
FROM reddit_items ri
JOIN reddit_sources rs ON ri.source_id = rs.id
WHERE rs.user_id = $1
  AND ($4::int IS NULL OR rs.group_id = $4::int)
ORDER BY ri.created_utc DESC
LIMIT $2 OFFSET $3
`

type ListRedditItemsParams struct {
	UserID  int32         `json:"user_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
	GroupID sql.NullInt32 `json:"group_id"`
}

func (q *Queries) ListRedditItems(ctx context.Context, arg ListRedditItemsParams) ([]RedditItem, error) {
	rows, err := q.db.QueryContext(ctx, listRedditItems,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.GroupID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RedditItem
	for rows.Next() {
		var i RedditItem
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Platform,
			&i.Subreddit,
			&i.ExternalID,
			&i.ExternalUrl,
			&i.Title,
			&i.Body,
			&i.Author,
			&i.AuthorFlair,
			&i.Score,
			&i.NumComments,
			&i.CreatedUtc,
			&i.FetchedAt,
			&i.QualityScore,
			&i.Nsfw,
			&i.Removed,
			&i.RawJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRedditSources = `-- name: ListRedditSources :many
SELECT id, user_id, group_id, type, value, subreddit, enabled, created_at FROM reddit_sources
WHERE user_id = $1
  AND ($2::int IS NULL OR group_id = $2::int)
ORDER BY created_at DESC
`

type ListRedditSourcesParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

func (q *Queries) ListRedditSources(ctx context.Context, arg ListRedditSourcesParams) ([]RedditSource, error) {
	rows, err := q.db.QueryContext(ctx, listRedditSources, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RedditSource
	for rows.Next() {
		var i RedditSource
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Type,
			&i.Value,
			&i.Subreddit,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStrategyCards = `-- name: ListStrategyCards :many
SELECT sc.id, sc.source, sc.item_id, sc.comment_id, sc.platform_targets, sc.niche, sc.tactic, sc.steps, sc.preconditions, sc.metrics, sc.risks, sc.confidence, sc.evidence, sc.created_at 
FROM strategy_cards sc
JOIN reddit_items ri ON sc.item_id = ri.id
JOIN reddit_sources rs ON ri.source_id = rs.id
WHERE rs.user_id = $1
  AND ($4::int IS NULL OR rs.group_id = $4::int)
ORDER BY sc.created_at DESC
LIMIT $2 OFFSET $3
`

type ListStrategyCardsParams struct {
	UserID  int32         `json:"user_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
	GroupID sql.NullInt32 `json:"group_id"`
}

func (q *Queries) ListStrategyCards(ctx context.Context, arg ListStrategyCardsParams) ([]StrategyCard, error) {
	rows, err := q.db.QueryContext(ctx, listStrategyCards,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.GroupID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StrategyCard
	for rows.Next() {
		var i StrategyCard
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.ItemID,
			&i.CommentID,
			pq.Array(&i.PlatformTargets),
			&i.Niche,
			&i.Tactic,
			&i.Steps,
			&i.Preconditions,
			&i.Metrics,
			&i.Risks,
			&i.Confidence,
			&i.Evidence,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
