// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: campaigns.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const bulkCreateDraft = `-- name: BulkCreateDraft :exec
INSERT INTO post_drafts (
  campaign_id, platform, post_type, hook, caption, hashtags, cta,
  time_window, reason_codes, confidence, status
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8::jsonb,
  $9,
  $10,
  $11
)
`

type BulkCreateDraftParams struct {
	CampaignID  uuid.UUID       `json:"campaign_id"`
	Platform    string          `json:"platform"`
	PostType    string          `json:"post_type"`
	Hook        sql.NullString  `json:"hook"`
	Caption     sql.NullString  `json:"caption"`
	Hashtags    []string        `json:"hashtags"`
	Cta         sql.NullString  `json:"cta"`
	TimeWindow  json.RawMessage `json:"time_window"`
	ReasonCodes []string        `json:"reason_codes"`
	Confidence  sql.NullString  `json:"confidence"`
	Status      string          `json:"status"`
}

func (q *Queries) BulkCreateDraft(ctx context.Context, arg BulkCreateDraftParams) error {
	_, err := q.db.ExecContext(ctx, bulkCreateDraft,
		arg.CampaignID,
		arg.Platform,
		arg.PostType,
		arg.Hook,
		arg.Caption,
		pq.Array(arg.Hashtags),
		arg.Cta,
		arg.TimeWindow,
		pq.Array(arg.ReasonCodes),
		arg.Confidence,
		arg.Status,
	)
	return err
}

const createCampaign = `-- name: CreateCampaign :one

INSERT INTO campaigns (user_id, group_id, name, goal, audience, pillars, cadence, status)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5::jsonb,
  $6::jsonb,
  $7::jsonb,
  $8
)
RETURNING id, user_id, group_id, name, goal, audience, pillars, cadence, status, created_at, updated_at
`

type CreateCampaignParams struct {
	UserID   int32           `json:"user_id"`
	GroupID  sql.NullInt32   `json:"group_id"`
	Name     string          `json:"name"`
	Goal     string          `json:"goal"`
	Audience json.RawMessage `json:"audience"`
	Pillars  json.RawMessage `json:"pillars"`
	Cadence  json.RawMessage `json:"cadence"`
	Status   string          `json:"status"`
}

// Campaigns CRUD
func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, createCampaign,
		arg.UserID,
		arg.GroupID,
		arg.Name,
		arg.Goal,
		arg.Audience,
		arg.Pillars,
		arg.Cadence,
		arg.Status,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Name,
		&i.Goal,
		&i.Audience,
		&i.Pillars,
		&i.Cadence,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCampaignAsset = `-- name: CreateCampaignAsset :one

INSERT INTO campaign_assets (campaign_id, storage_url, filename, mime_type, size_bytes, tags)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6::jsonb
)
RETURNING id, campaign_id, storage_url, filename, mime_type, size_bytes, tags, created_at
`

type CreateCampaignAssetParams struct {
	CampaignID uuid.UUID       `json:"campaign_id"`
	StorageUrl string          `json:"storage_url"`
	Filename   string          `json:"filename"`
	MimeType   sql.NullString  `json:"mime_type"`
	SizeBytes  sql.NullInt64   `json:"size_bytes"`
	Tags       json.RawMessage `json:"tags"`
}

// Campaign Assets
func (q *Queries) CreateCampaignAsset(ctx context.Context, arg CreateCampaignAssetParams) (CampaignAsset, error) {
	row := q.db.QueryRowContext(ctx, createCampaignAsset,
		arg.CampaignID,
		arg.StorageUrl,
		arg.Filename,
		arg.MimeType,
		arg.SizeBytes,
		arg.Tags,
	)
	var i CampaignAsset
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.StorageUrl,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.Tags,
		&i.CreatedAt,
	)
	return i, err
}

const createPostDraft = `-- name: CreatePostDraft :one

INSERT INTO post_drafts (
  campaign_id, platform, post_type, hook, caption, hashtags, cta, 
  time_window, reason_codes, confidence, status
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8::jsonb,
  $9,
  $10,
  $11
)
RETURNING id, campaign_id, platform, post_type, hook, caption, hashtags, cta, time_window, reason_codes, confidence, status, scheduled_at, created_at, updated_at
`

type CreatePostDraftParams struct {
	CampaignID  uuid.UUID       `json:"campaign_id"`
	Platform    string          `json:"platform"`
	PostType    string          `json:"post_type"`
	Hook        sql.NullString  `json:"hook"`
	Caption     sql.NullString  `json:"caption"`
	Hashtags    []string        `json:"hashtags"`
	Cta         sql.NullString  `json:"cta"`
	TimeWindow  json.RawMessage `json:"time_window"`
	ReasonCodes []string        `json:"reason_codes"`
	Confidence  sql.NullString  `json:"confidence"`
	Status      string          `json:"status"`
}

// Post Drafts
func (q *Queries) CreatePostDraft(ctx context.Context, arg CreatePostDraftParams) (PostDraft, error) {
	row := q.db.QueryRowContext(ctx, createPostDraft,
		arg.CampaignID,
		arg.Platform,
		arg.PostType,
		arg.Hook,
		arg.Caption,
		pq.Array(arg.Hashtags),
		arg.Cta,
		arg.TimeWindow,
		pq.Array(arg.ReasonCodes),
		arg.Confidence,
		arg.Status,
	)
	var i PostDraft
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Platform,
		&i.PostType,
		&i.Hook,
		&i.Caption,
		pq.Array(&i.Hashtags),
		&i.Cta,
		&i.TimeWindow,
		pq.Array(&i.ReasonCodes),
		&i.Confidence,
		&i.Status,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCampaign = `-- name: DeleteCampaign :exec
DELETE FROM campaigns WHERE id = $1
`

func (q *Queries) DeleteCampaign(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCampaign, id)
	return err
}

const deleteCampaignAsset = `-- name: DeleteCampaignAsset :exec
DELETE FROM campaign_assets WHERE id = $1
`

func (q *Queries) DeleteCampaignAsset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCampaignAsset, id)
	return err
}

const deleteDraftsByCampaign = `-- name: DeleteDraftsByCampaign :exec
DELETE FROM post_drafts WHERE campaign_id = $1
`

func (q *Queries) DeleteDraftsByCampaign(ctx context.Context, campaignID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteDraftsByCampaign, campaignID)
	return err
}

const getBestPostingWindows = `-- name: GetBestPostingWindows :many
SELECT
  EXTRACT(DOW FROM captured_at)::int as day_of_week,
  EXTRACT(HOUR FROM captured_at)::int as hour_of_day,
  AVG((metrics->>'engagement_rate')::numeric) as avg_engagement,
  COUNT(*) as sample_size
FROM post_metrics
WHERE group_id = $1 AND captured_at >= NOW() - INTERVAL '28 days'
GROUP BY EXTRACT(DOW FROM captured_at), EXTRACT(HOUR FROM captured_at)
HAVING COUNT(*) >= 3
ORDER BY avg_engagement DESC
LIMIT 10
`

type GetBestPostingWindowsRow struct {
	DayOfWeek     int32   `json:"day_of_week"`
	HourOfDay     int32   `json:"hour_of_day"`
	AvgEngagement float64 `json:"avg_engagement"`
	SampleSize    int64   `json:"sample_size"`
}

func (q *Queries) GetBestPostingWindows(ctx context.Context, groupID int32) ([]GetBestPostingWindowsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBestPostingWindows, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBestPostingWindowsRow
	for rows.Next() {
		var i GetBestPostingWindowsRow
		if err := rows.Scan(
			&i.DayOfWeek,
			&i.HourOfDay,
			&i.AvgEngagement,
			&i.SampleSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCampaignByID = `-- name: GetCampaignByID :one
SELECT id, user_id, group_id, name, goal, audience, pillars, cadence, status, created_at, updated_at FROM campaigns WHERE id = $1
`

func (q *Queries) GetCampaignByID(ctx context.Context, id uuid.UUID) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, getCampaignByID, id)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Name,
		&i.Goal,
		&i.Audience,
		&i.Pillars,
		&i.Cadence,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMetricsSummary = `-- name: GetMetricsSummary :one
SELECT
  COUNT(DISTINCT post_id) as total_posts,
  AVG((metrics->>'impressions')::numeric) as avg_impressions,
  AVG((metrics->>'engagement_rate')::numeric) as avg_engagement,
  AVG((metrics->>'likes')::numeric) as avg_likes,
  AVG((metrics->>'comments')::numeric) as avg_comments,
  AVG((metrics->>'shares')::numeric) as avg_shares
FROM post_metrics
WHERE group_id = $1 AND captured_at >= $2
`

type GetMetricsSummaryParams struct {
	GroupID    int32     `json:"group_id"`
	CapturedAt time.Time `json:"captured_at"`
}

type GetMetricsSummaryRow struct {
	TotalPosts     int64   `json:"total_posts"`
	AvgImpressions float64 `json:"avg_impressions"`
	AvgEngagement  float64 `json:"avg_engagement"`
	AvgLikes       float64 `json:"avg_likes"`
	AvgComments    float64 `json:"avg_comments"`
	AvgShares      float64 `json:"avg_shares"`
}

func (q *Queries) GetMetricsSummary(ctx context.Context, arg GetMetricsSummaryParams) (GetMetricsSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getMetricsSummary, arg.GroupID, arg.CapturedAt)
	var i GetMetricsSummaryRow
	err := row.Scan(
		&i.TotalPosts,
		&i.AvgImpressions,
		&i.AvgEngagement,
		&i.AvgLikes,
		&i.AvgComments,
		&i.AvgShares,
	)
	return i, err
}

const getPostDraftByID = `-- name: GetPostDraftByID :one
SELECT id, campaign_id, platform, post_type, hook, caption, hashtags, cta, time_window, reason_codes, confidence, status, scheduled_at, created_at, updated_at FROM post_drafts WHERE id = $1
`

func (q *Queries) GetPostDraftByID(ctx context.Context, id uuid.UUID) (PostDraft, error) {
	row := q.db.QueryRowContext(ctx, getPostDraftByID, id)
	var i PostDraft
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Platform,
		&i.PostType,
		&i.Hook,
		&i.Caption,
		pq.Array(&i.Hashtags),
		&i.Cta,
		&i.TimeWindow,
		pq.Array(&i.ReasonCodes),
		&i.Confidence,
		&i.Status,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopHookPatterns = `-- name: GetTopHookPatterns :many
SELECT
  pd.hook,
  AVG((pm.metrics->>'engagement_rate')::numeric) as avg_engagement,
  COUNT(*) as usage_count
FROM post_drafts pd
JOIN post_metrics pm ON pm.draft_id = pd.id
WHERE pd.campaign_id IN (SELECT id FROM campaigns c WHERE c.group_id = $1::int)
  AND pm.captured_at >= NOW() - INTERVAL '28 days'
  AND pd.hook IS NOT NULL AND pd.hook != ''
GROUP BY pd.hook
HAVING COUNT(*) >= 2
ORDER BY avg_engagement DESC
LIMIT 10
`

type GetTopHookPatternsRow struct {
	Hook          sql.NullString `json:"hook"`
	AvgEngagement float64        `json:"avg_engagement"`
	UsageCount    int64          `json:"usage_count"`
}

func (q *Queries) GetTopHookPatterns(ctx context.Context, groupID int32) ([]GetTopHookPatternsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopHookPatterns, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopHookPatternsRow
	for rows.Next() {
		var i GetTopHookPatternsRow
		if err := rows.Scan(&i.Hook, &i.AvgEngagement, &i.UsageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPostMetrics = `-- name: InsertPostMetrics :one

INSERT INTO post_metrics (group_id, platform, post_id, draft_id, metrics, captured_at)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5::jsonb,
  COALESCE($6, NOW())
)
ON CONFLICT (group_id, platform, post_id, captured_at) DO UPDATE
SET metrics = EXCLUDED.metrics
RETURNING id, group_id, platform, post_id, draft_id, captured_at, metrics
`

type InsertPostMetricsParams struct {
	GroupID    int32           `json:"group_id"`
	Platform   string          `json:"platform"`
	PostID     string          `json:"post_id"`
	DraftID    uuid.NullUUID   `json:"draft_id"`
	Metrics    json.RawMessage `json:"metrics"`
	CapturedAt interface{}     `json:"captured_at"`
}

// Post Metrics
func (q *Queries) InsertPostMetrics(ctx context.Context, arg InsertPostMetricsParams) (PostMetric, error) {
	row := q.db.QueryRowContext(ctx, insertPostMetrics,
		arg.GroupID,
		arg.Platform,
		arg.PostID,
		arg.DraftID,
		arg.Metrics,
		arg.CapturedAt,
	)
	var i PostMetric
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Platform,
		&i.PostID,
		&i.DraftID,
		&i.CapturedAt,
		&i.Metrics,
	)
	return i, err
}

const listCampaignAssets = `-- name: ListCampaignAssets :many
SELECT id, campaign_id, storage_url, filename, mime_type, size_bytes, tags, created_at FROM campaign_assets
WHERE campaign_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCampaignAssets(ctx context.Context, campaignID uuid.UUID) ([]CampaignAsset, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignAssets, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CampaignAsset
	for rows.Next() {
		var i CampaignAsset
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.StorageUrl,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.Tags,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignsByGroup = `-- name: ListCampaignsByGroup :many
SELECT id, user_id, group_id, name, goal, audience, pillars, cadence, status, created_at, updated_at FROM campaigns
WHERE group_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCampaignsByGroup(ctx context.Context, groupID sql.NullInt32) ([]Campaign, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignsByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Campaign
	for rows.Next() {
		var i Campaign
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Name,
			&i.Goal,
			&i.Audience,
			&i.Pillars,
			&i.Cadence,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignsByUser = `-- name: ListCampaignsByUser :many
SELECT id, user_id, group_id, name, goal, audience, pillars, cadence, status, created_at, updated_at FROM campaigns
WHERE user_id = $1 
  AND (group_id = $2 OR group_id IS NULL OR $2 IS NULL)
ORDER BY created_at DESC
`

type ListCampaignsByUserParams struct {
	UserID  int32         `json:"user_id"`
	GroupID sql.NullInt32 `json:"group_id"`
}

func (q *Queries) ListCampaignsByUser(ctx context.Context, arg ListCampaignsByUserParams) ([]Campaign, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignsByUser, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Campaign
	for rows.Next() {
		var i Campaign
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Name,
			&i.Goal,
			&i.Audience,
			&i.Pillars,
			&i.Cadence,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftsByCampaign = `-- name: ListDraftsByCampaign :many
SELECT id, campaign_id, platform, post_type, hook, caption, hashtags, cta, time_window, reason_codes, confidence, status, scheduled_at, created_at, updated_at FROM post_drafts
WHERE campaign_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListDraftsByCampaign(ctx context.Context, campaignID uuid.UUID) ([]PostDraft, error) {
	rows, err := q.db.QueryContext(ctx, listDraftsByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostDraft
	for rows.Next() {
		var i PostDraft
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Platform,
			&i.PostType,
			&i.Hook,
			&i.Caption,
			pq.Array(&i.Hashtags),
			&i.Cta,
			&i.TimeWindow,
			pq.Array(&i.ReasonCodes),
			&i.Confidence,
			&i.Status,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftsByStatus = `-- name: ListDraftsByStatus :many
SELECT id, campaign_id, platform, post_type, hook, caption, hashtags, cta, time_window, reason_codes, confidence, status, scheduled_at, created_at, updated_at FROM post_drafts
WHERE campaign_id = $1 AND status = $2
ORDER BY created_at DESC
`

type ListDraftsByStatusParams struct {
	CampaignID uuid.UUID `json:"campaign_id"`
	Status     string    `json:"status"`
}

func (q *Queries) ListDraftsByStatus(ctx context.Context, arg ListDraftsByStatusParams) ([]PostDraft, error) {
	rows, err := q.db.QueryContext(ctx, listDraftsByStatus, arg.CampaignID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostDraft
	for rows.Next() {
		var i PostDraft
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Platform,
			&i.PostType,
			&i.Hook,
			&i.Caption,
			pq.Array(&i.Hashtags),
			&i.Cta,
			&i.TimeWindow,
			pq.Array(&i.ReasonCodes),
			&i.Confidence,
			&i.Status,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricsByDraft = `-- name: ListMetricsByDraft :many
SELECT id, group_id, platform, post_id, draft_id, captured_at, metrics FROM post_metrics
WHERE draft_id = $1
ORDER BY captured_at DESC
`

func (q *Queries) ListMetricsByDraft(ctx context.Context, draftID uuid.NullUUID) ([]PostMetric, error) {
	rows, err := q.db.QueryContext(ctx, listMetricsByDraft, draftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostMetric
	for rows.Next() {
		var i PostMetric
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Platform,
			&i.PostID,
			&i.DraftID,
			&i.CapturedAt,
			&i.Metrics,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricsByGroup = `-- name: ListMetricsByGroup :many
SELECT id, group_id, platform, post_id, draft_id, captured_at, metrics FROM post_metrics
WHERE group_id = $1 AND captured_at >= $2
ORDER BY captured_at DESC
`

type ListMetricsByGroupParams struct {
	GroupID    int32     `json:"group_id"`
	CapturedAt time.Time `json:"captured_at"`
}

func (q *Queries) ListMetricsByGroup(ctx context.Context, arg ListMetricsByGroupParams) ([]PostMetric, error) {
	rows, err := q.db.QueryContext(ctx, listMetricsByGroup, arg.GroupID, arg.CapturedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostMetric
	for rows.Next() {
		var i PostMetric
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Platform,
			&i.PostID,
			&i.DraftID,
			&i.CapturedAt,
			&i.Metrics,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCampaign = `-- name: UpdateCampaign :one
UPDATE campaigns
SET name = $1,
    goal = $2,
    audience = $3::jsonb,
    pillars = $4::jsonb,
    cadence = $5::jsonb
WHERE id = $6
RETURNING id, user_id, group_id, name, goal, audience, pillars, cadence, status, created_at, updated_at
`

type UpdateCampaignParams struct {
	Name     string          `json:"name"`
	Goal     string          `json:"goal"`
	Audience json.RawMessage `json:"audience"`
	Pillars  json.RawMessage `json:"pillars"`
	Cadence  json.RawMessage `json:"cadence"`
	ID       uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, updateCampaign,
		arg.Name,
		arg.Goal,
		arg.Audience,
		arg.Pillars,
		arg.Cadence,
		arg.ID,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Name,
		&i.Goal,
		&i.Audience,
		&i.Pillars,
		&i.Cadence,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCampaignStatus = `-- name: UpdateCampaignStatus :exec
UPDATE campaigns SET status = $2 WHERE id = $1
`

type UpdateCampaignStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateCampaignStatus(ctx context.Context, arg UpdateCampaignStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCampaignStatus, arg.ID, arg.Status)
	return err
}

const updateDraftSchedule = `-- name: UpdateDraftSchedule :exec
UPDATE post_drafts SET scheduled_at = $2, status = 'scheduled' WHERE id = $1
`

type UpdateDraftScheduleParams struct {
	ID          uuid.UUID    `json:"id"`
	ScheduledAt sql.NullTime `json:"scheduled_at"`
}

func (q *Queries) UpdateDraftSchedule(ctx context.Context, arg UpdateDraftScheduleParams) error {
	_, err := q.db.ExecContext(ctx, updateDraftSchedule, arg.ID, arg.ScheduledAt)
	return err
}

const updateDraftStatus = `-- name: UpdateDraftStatus :exec
UPDATE post_drafts SET status = $2 WHERE id = $1
`

type UpdateDraftStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateDraftStatus(ctx context.Context, arg UpdateDraftStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateDraftStatus, arg.ID, arg.Status)
	return err
}
